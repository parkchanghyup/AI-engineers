# 네트워크 vs 네트워킹?
`네트워크(network)`는 컴퓨터, 기기, 서버 등이 연결되어 데이터를 주고받을 수 있는 물리적 또는 논리적인 연결 구조를 의미함.   
즉, 네트워크는 서로 다른 기기들 간에 데이터를 교환할 수 있는 통로를 제공하는 인프라를 말합니다.  

반면에 `네트워킹(networking)`은 네트워크를 구성하고 유지하는 과정을 의미한다. 
이는 컴퓨터, 기기, 서버 등을 연결하고 구성하여 데이터 전송을 위한 환경을 구축하는 것을 포함합니다. 네트워킹은 **네트워크 구성 요소를 설치, 구성 및 유지 보수하고, 데이터의 안정적인 전송과 보안을 보장하기 위한 작업을 포함**합니다.  

**즉, 네트워크는 물리적 또는 논리적인 구조를 나타내는 반면, 네트워킹은 이러한 구조를 구성하고 유지 보수하는 프로세스를 나타냅니다.**
# OSI 7계층이란
 각 계층이 서로 독립적인 기능을 수행하여 서로 다른 시스템 간의 통신을 가능하게 합니다.

7개의 계층은 아래와 같다.

- 물리 계층 (Physical Layer)
    - 전기적, 물리적 신호를 전송하는 역할
- 데이터 링크 계층 (Data Link Layer)
    - 물리 계층에서 전송되는 비트를 블록으로 나누고, 에러 검사 및 흐름 제어 등을 수행하는 역할
- 네트워크 계층 (Network Layer)
    - 경로 선택 및 패킷 전달 등을 수행하는 역할
- 전송 계층 (Transport Layer)
    - 신뢰성 있는 데이터 전송, 흐름 제어, 오류 복구 등을 수행하는 역할
- 세션 계층 (Session Layer)
    - 양 끝단의 응용 프로세스 간의 대화를 관리하는 역할
- 표현 계층 (Presentation Layer)
    - 데이터의 표현 형식 변환, 암호화, 복호화 등을 수행하는 역할
- 응용 계층 (Application Layer)
    - 사용자가 네트워크에 접근하여 데이터를 전송할 수 있도록 하는 인터페이스를 제공하는 역할
    
각 계층은 그 계층의 역할에만 집중하고, 상위 계층은 하위 계층이 제공하는 기능을 이용하여 데이터를 처리하고 하위 계층은 상위 계층에게 제공되는 인터페이스를 이용하여 데이터를 전달합니다. 이러한 구조로 인해 계층간의 `독립성`, `유연성`, `기능의 분리 및 표준화`,` 문제 해결의 용이성` 등의 장점이 있습니다.

# TCP/IP 4계층 이란
`TCP/IP`는 OSI 모델과는 달리 **4계층(네트워크 계층, 전송 계층, 응용 계층)**으로 구성되어 있습니다. 네트워크 계층에서는 IP 프로토콜을 사용하여 데이터를 목적지로 전송하고, 전송 계층에서는 TCP 또는 UDP 프로토콜을 사용하여 호스트 간의 데이터 전송을 담당합니다. 응용 계층에서는 HTTP, FTP, SMTP 등의 프로토콜을 사용하여 응용 프로그램 간의 데이터 통신을 제공합니다.
  
TCP/IP는 인터넷을 비롯한 다양한 네트워크에서 사용되는 표준 프로토콜 스택이기 때문에, 다양한 운영체제나 네트워크 장비에서 지원되고 있습니다. 따라서, **인터넷과 관련된 다양한 서비스를 구현할 때에는 TCP/IP 프로토콜 스택을 이용하여 구현하는 것이 일반적입니다.**

# IPv4주소의 기본 구조
IPv4 주소는 32비트로 이루어진 주소 체계이다.  
보통 10진수 4개의 숫자로 표기되고, 각 숫자는 0부터 255 사이의 값입니다.  

예를 들어, 192.168.0.1은 4개의 숫자로 이루어진 IPv4 주소입니다. 이 주소는 32비트로 표현하면 다음과 같이 나타낼 수 있습니다.  

`11000000.10101000.00000000.00000001`  

IPv4 주소의 첫 번째 8비트는 네트워크를 식별하는 데 사용되고 이를 `네트워크 주소`라고 합니다. 나머지 24비트는 **호스트를 식별하는 데 사용**됩니다. 이를 `호스트 주소`라고 합니다.  

따라서, IPv4 주소의 기본 구조는 네트워크 주소와 호스트 주소로 이루어진 32비트 주소 체계입니다. 이를 통해 인터넷 상에서 호스트를 식별하고 통신할 수 있습니다.   

# Encapulation과 Decapulation

`Encapsulation(캡슐화)`과 `Decapsulation(역캡슐화)`은 네트워크에서 데이터를 전송하는 과정에서 사용되는 용어입니다.

`Encapsulation은` 데이터를 패킷화하여 헤더와 트레일러를 추가하는 과정입니다. 이 과정에서 데이터는 하위 계층에서 상위 계층으로 이동하며, 각 계층에서 해당하는 프로토콜의 헤더와 트레일러를 추가합니다. 예를 들어, TCP 프로토콜을 사용하는 응용 프로그램에서 데이터를 보낼 때, 데이터는 TCP 세그먼트로 캡슐화되고, 이후에 IP 데이터그램으로 캡슐화됩니다. 마지막으로, 이 데이터그램에 이더넷 헤더와 트레일러가 추가되어 네트워크를 통해 전송됩니다.

`Decapsulation은` 전송된 패킷에서 헤더와 트레일러를 제거하여 데이터를 추출하는 과정입니다. 이 과정에서 데이터는 상위 계층에서 하위 계층으로 이동하며, 각 계층에서 해당하는 헤더와 트레일러를 제거합니다. 예를 들어, IP 데이터그램을 수신한 호스트는 이더넷 헤더와 트레일러를 제거하고, IP 데이터그램에서 TCP 세그먼트를 추출합니다. 이후에, 이 세그먼트에서 응용 프로그램의 데이터를 추출하여 처리합니다.

요약하면, Encapsulation과 Decapsulation은 네트워크에서 데이터를 전송하는 과정에서 중요한 역할을 합니다. Encapsulation은 데이터를 캡슐화하여 하위 계층에서 상위 계층으로 전송하고, Decapsulation은 전송된 패킷에서 헤더와 트레일러를 제거하여 데이터를 추출합니다.

# 서브넷 마스크와 CIDR

`서브넷 마스크(Subnet Mask)`와 `CIDR(Classless Inter-Domain Routing`)은 IP 주소 체계에서 서브넷(Subnet)을 정의하는 방법입니다.

서브넷 마스크는 IP 주소 체계에서 네트워크 주소와 호스트 주소를 분리하는 기능을 합니다. 이를 통해 IP 주소 체계에서 서브넷을 정의할 수 있습니다. 서브넷 마스크는 32비트의 이진수로 표현되며, IP 주소의 네트워크 부분은 모두 1로, 호스트 부분은 모두 0으로 표시됩니다. 예를 들어, 255.255.255.0은 32비트 이진수로 11111111.11111111.11111111.00000000으로 표현됩니다. 이는 네트워크 부분이 24비트, 호스트 부분이 8비트로 구성된 서브넷을 나타냅니다.

CIDR은 서브넷 마스크를 좀 더 간단하고 유연하게 나타내는 방법입니다. CIDR은 IP 주소 체계에서 서브넷 마스크를 비트 수로 나타냅니다. 예를 들어, /24는 24비트의 서브넷 마스크를 나타냅니다. 이는 255.255.255.0과 동일한 의미입니다. CIDR은 서브넷을 더 세밀하게 정의할 수 있는 장점이 있습니다. 예를 들어, /27은 27비트의 서브넷 마스크를 나타내며, 이는 32개의 서브넷과 각각 32개의 호스트를 가질 수 있는 네트워크를 나타냅니다.

따라서, 서브넷 마스크와 CIDR은 IP 주소 체계에서 서브넷을 정의하는 방법입니다. 서브넷 마스크는 이진수로 표시된 서브넷을 나타내며, CIDR은 비트 수로 표시된 서브넷을 나타냅니다.

# TCP와 UDP의 차이
TCP와 UDP는 모두 인터넷 프로토콜 스위트(IP)의 전송 계층에 속하는 프로토콜로, 데이터를 전송하는데 사용됩니다. 그러나 두 프로토콜은 몇 가지 중요한 차이점이 있습니다.

### 연결성(Connection-oriented) vs 비연결성(Connectionless)
TCP는 연결 지향적인 프로토콜로, 두 시스템 간에 신뢰성 있는 연결을 설정한 후 데이터를 전송합니다. 반면, UDP는 비연결성 프로토콜로, 연결 설정 없이 데이터를 전송합니다.

### 신뢰성(Reliability)
TCP는 패킷의 손실을 검출하고 복구하는 기능을 가지고 있습니다. 데이터의 정확한 전달을 보장하기 위해 재전송이나 에러 검출 등의 기능을 사용합니다. 반면, UDP는 패킷 손실 검출 기능만 가지고 있고, 데이터의 전달 여부나 정확성은 보장하지 않습니다.

### 순서 보장(Ordering)
TCP는 전송된 데이터의 순서를 보장합니다. 데이터는 전송 순서대로 받아지며, 받는 쪽에서 패킷의 순서를 재조립합니다. 반면, UDP는 데이터의 전송 순서를 보장하지 않습니다.

### 대역폭 사용(Bandwidth Usage)
TCP는 데이터를 전송하기 전에 먼저 연결을 설정하고, 패킷의 손실이나 재전송이 필요할 경우에 대비해 불필요한 대역폭을 사용합니다. 반면, UDP는 연결 설정이 필요 없으며, 패킷 손실이나 재전송 등의 검사를 하지 않기 때문에 대역폭을 적게 사용합니다.

### 지원하는 응용 프로그램(Applications Supported)

TCP는 데이터의 신뢰성과 정확성이 중요한 응용 프로그램에 적합합니다. 예를 들어, 파일 전송, 이메일, 웹 브라우징 등에 사용됩니다.

반면, UDP는 데이터의 속도와 대역폭이 중요한 응용 프로그램에 적합합니다. UDP는 연속적인 데이터 전송이 중요하지 않고, 지연 시간이 짧아야 하는 응용 프로그램에 사용됩니다. 예를 들어, 동영상 스트리밍, 음성 통화, 온라인 게임 등에 사용됩니다.

따라서, TCP와 UDP는 각각의 특징과 용도에 따라 선택하여 사용해야 합니다. 데이터의 정확성과 신뢰성이 중요한 경우에는 TCP를, 데이터의 속도와 대역폭이 중요한 경우에는 UDP를 사용합니다.

# TCP의 3-way-handshake와 4-way-handsake
TCP는 데이터의 신뢰성을 보장하기 위해 연결 지향적인 프로토콜입니다. TCP의 3-way-handshake는 클라이언트와 서버 간에 연결을 설정할 때 사용되며, 4-way-handshake는 연결을 종료할 때 사용됩니다.

3-way-handshake는 다음과 같은 순서로 이루어집니다.

클라이언트는 SYN 패킷을 보내서 서버에게 연결을 요청합니다. SYN은 synchronize(동기화)를 의미합니다.
서버는 SYN 패킷을 받고, SYN과 ACK(acknowledgement, 수신 확인)를 보내서 클라이언트의 요청을 수락합니다.
클라이언트는 서버의 응답을 받고, ACK를 보내서 연결이 설정되었음을 알립니다.
이제 클라이언트와 서버는 데이터를 주고받을 수 있습니다.

4-way-handshake는 다음과 같은 순서로 이루어집니다.

클라이언트는 연결 종료를 요청하는 FIN 패킷을 보냅니다.
서버는 FIN 패킷을 받고, ACK를 보내서 요청을 수락합니다. 이때 서버는 아직 보내지 않은 데이터가 있을 수 있으므로, 이어서 데이터를 보낼 수 있습니다.
서버가 모든 데이터를 보냈다면, 연결 종료를 요청하는 FIN 패킷을 클라이언트에게 보냅니다.
클라이언트는 FIN 패킷을 받고, ACK를 보내서 요청을 수락합니다. 이후에도 서버로부터 데이터가 오는 경우를 대비해서, 일정 시간 동안 연결을 유지합니다. 이 시간을 TIME_WAIT라고 합니다.
이러한 3-way-handshake와 4-way-handshake는 TCP의 연결 지향적인 특성을 활용하여 데이터의 신뢰성을 보장합니다.

# TCP의 연결 설정 과정과 연결 종료 과정이 차이가 나는 이유는?
TCP는 연결 지향적인 프로토콜로서, 데이터의 전송을 위해 먼저 연결 설정 과정을 거칩니다. 이후 데이터를 전송하고, 데이터의 전송이 완료되면 연결을 종료합니다.

TCP의 연결 설정 과정에서는 3-way handshake 프로토콜을 사용합니다. 클라이언트는 SYN 패킷을 서버에 보내고, 서버는 SYN-ACK 패킷을 클라이언트에 보내면서 연결 요청을 수락하는 것을 알립니다. 이후 클라이언트는 ACK 패킷을 서버에 보내면서 연결이 설정됩니다. 이 과정은 데이터 전송 전에 반드시 필요한 과정이기 때문에, 연결 설정 과정이 반드시 수행되어야 합니다.

반면에 TCP의 연결 종료 과정에서는 4-way handshake 프로토콜을 사용합니다. 클라이언트는 FIN 패킷을 서버에 보내고, 서버는 ACK 패킷을 클라이언트에 보내면서 연결 종료를 인지합니다. 이후 서버는 자신도 데이터를 모두 전송했음을 알리기 위해 FIN 패킷을 클라이언트에 보냅니다. 마지막으로 클라이언트는 ACK 패킷을 서버에 보내면서 연결을 완전히 종료합니다.

연결 설정 과정과 연결 종료 과정에서 차이가 있는 이유는, 연결 설정 과정에서는 양쪽 모두에서 데이터를 전송하기 전에 상대방이 존재하는지 확인해야 하기 때문입니다. 반면에 연결 종료 과정에서는 양쪽 모두에서 모든 데이터를 전송한 후에 연결을 종료해야 하기 때문에, 추가적인 과정이 필요합니다.

# HTTP 메서드 종류와 설명
HTTP는 HyperText Transfer Protocol(하이퍼텍스트 전송 프로토콜)의 약자로, 웹 브라우저와 웹 서버 간의 통신을 위한 프로토콜입니다. HTTP 메서드는 웹 브라우저가 서버에 요청을 보낼 때 어떤 동작을 수행할지를 지정하는 방법입니다. HTTP 메서드는 다음과 같습니다.

- `GET`: 웹 서버에서 정보를 요청하는 메서드입니다. 요청한 리소스를 가져오고자 할 때 사용됩니다.

- `POST`: 서버에 데이터를 제출하는 메서드입니다. 주로 사용자가 입력한 정보를 서버에 제출하는 경우에 사용됩니다.

- `PUT`: 서버에 데이터를 업데이트하는 메서드입니다. 요청한 리소스가 존재하면 데이터를 업데이트하고, 존재하지 않으면 새로운 리소스를 생성합니다.

- `DELETE`: 서버에서 데이터를 삭제하는 메서드입니다. 요청한 리소스를 삭제합니다.

- `PATCH`: PUT 메서드와 비슷하지만, 서버에 요청한 리소스에서 일부 데이터만 업데이트하는 메서드입니다.

- `HEAD`: GET 메서드와 비슷하지만, 서버에서 응답으로 리소스의 본문(body)을 제외한 헤더(header) 정보만을 전송합니다.

- `OPTIONS`: 서버에서 지원하는 메서드 종류나 리소스의 메타 데이터 등을 요청하는 메서드입니다.

- `CONNECT`: 클라이언트와 서버 간의 터널을 연결하는 메서드입니다.

- `TRACE`: 클라이언트가 서버로 보낸 요청에 대한 응답을 받는 메서드입니다. 디버깅 용도로 사용됩니다.

- `PATCH`: 리소스의 일부를 수정하기 위해 사용되는 메서드입니다.

이러한 HTTP 메서드를 사용하여 웹 브라우저와 웹 서버 간의 통신을 수행합니다.
# 쿠키 vs 세션
`쿠키(Cookie)`와 `세션(Session)`은 웹 개발에서 사용되는 중요한 요소 중 두 가지입니다. 이 둘은 모두 `클라이언트-서버 모델`에서 사용되는 데이터 저장 기술이며, 서로 다른 목적을 가지고 있습니다.

쿠키는 **서버에서 클라이언트(브라우저)로 전송되는 작은 데이터 파일입니다. 이 파일은 클라이언트의 로컬 컴퓨터에 저장되며, 이후에 해당 웹사이트에 재방문할 때 웹사이트는 이 쿠키를 사용하여 클라이언트를 인식합니다.**

반면에, 세션은 **웹사이트에서 유저가 로그인하거나 회원가입을 하면 발생하는 일종의 상태(State)입니다. 서버 측에서 이 세션을 유지하며, 클라이언트와 서버 간의 통신을 통해 이 정보를 공유합니다. 세션은 일정 시간이 지나거나, 클라이언트가 웹사이트를 종료하면 종료됩니다.**

쿠키와 세션의 주요 차이점은 다음과 같습니다.

`저장 위치` : 쿠키는 클라이언트의 로컬 컴퓨터에 저장되고, 세션은 서버 측에 저장됩니다.

`보안성` : 쿠키는 클라이언트 측에 저장되기 때문에 보안에 취약할 수 있습니다. 해커가 쿠키를 탈취하면 해당 유저의 로그인 정보를 알 수 있습니다. 세션은 서버 측에서 관리되므로, 보안에 좀 더 강력합니다.

`유지 기간` : 쿠키는 만료일을 설정하여 일정 기간 동안 저장됩니다. 만료일이 없으면 브라우저를 종료해도 유지됩니다. 세션은 일정 시간 이후에 만료됩니다.

`용도` : 쿠키는 사용자 로그인 정보, 장바구니, 사용자 선호 설정 등을 저장하기 위해 사용됩니다. 세션은 보안상 중요한 정보를 저장하기 위해 사용됩니다.

따라서, 쿠키와 세션은 각각 다른 용도와 특성을 가지고 있으며, 웹 개발에서 적절하게 활용해야 합니다.

# DNS란?
`DNS(Domain Name System)`은 인터넷에서 사용되는 도메인 이름과 IP 주소를 연결하는 시스템입니다. 인터넷에서 통신할 때, 컴퓨터나 모바일 기기는 IP 주소를 이용하여 서버에 접속합니다. 그러나 IP 주소는 숫자로 되어있기 때문에 사람이 외우기 어렵습니다. 따라서**DNS는 이러한 IP 주소를 기억하기 쉬운 도메인 이름으로 변환해주는 역할을 합니다.**

# REST와 RESTful의 개념과 차이점

REST(Representational State Transfer)는 웹 서비스를 설계하는 데 사용되는 아키텍처 스타일입니다. RESTful은 이러한 REST 아키텍처 스타일을 따르는 웹 서비스를 말합니다.

REST는 클라이언트와 서버 간의 통신을 위한 일반적인 아키텍처 스타일로, HTTP 프로토콜을 기반으로 합니다. RESTful 웹 서비스는 이러한 REST 아키텍처 스타일을 따르면서도, 리소스 지향(Resource-oriented) 아키텍처 스타일을 따르는 웹 서비스입니다.

REST는 HTTP 메서드(GET, POST, PUT, DELETE 등)를 이용하여 리소스를 조작하며, URI(Uniform Resource Identifier)를 이용하여 리소스를 식별합니다. 리소스는 일반적으로 XML, JSON 등의 데이터 형식으로 반환됩니다. 이러한 RESTful 웹 서비스는 웹 기술을 이용하여 다른 애플리케이션과의 통합을 쉽게 구현할 수 있습니다.

RESTful 웹 서비스의 주요 특징은 다음과 같습니다.

리소스 중심적(Resource-centric) : 모든 데이터는 URI로 식별됩니다. 따라서, RESTful 웹 서비스는 각각의 리소스를 중심으로 구성됩니다.

자체 설명적(Self-descriptive) : RESTful 웹 서비스는 각각의 리소스가 자체적으로 설명 가능한 정보를 가지고 있어, 해당 리소스에 대한 정보를 받기 위해 다른 리소스에 대한 정보를 알 필요가 없습니다.

클라이언트-서버 구조 : RESTful 웹 서비스는 클라이언트와 서버 간의 역할을 분리하여, 서로간에 독립적인 진화를 가능하게 합니다.

상태 없음(Stateless) : RESTful 웹 서비스는 서버에서 클라이언트의 상태를 유지하지 않습니다. 따라서, 클라이언트의 요청에 대해 서버가 적절한 응답을 반환하기 위한 모든 정보는 요청에 포함되어야 합니다.

따라서, REST는 아키텍처 스타일이며, RESTful은 이러한 REST 아키텍처 스타일을 따르는 웹 서비스를 말합니다. RESTful 웹 서비스는 리소스 지향적인 아키텍처를 따르며, 웹 기술과의 통합이 용이하다는 장점을 가지고 있습니다.

# MAC adress란?
MAC(Medium Access Control) 주소는 네트워크 인터페이스 카드(Network Interface Card, NIC)에 할당된 고유한 식별자입니다. MAC 주소는 네트워크에서 통신을 하는 데 있어서 물리적인 주소 역할을 합니다.

MAC 주소는 6바이트 길이의 16진수 값으로 표현되며, 이는 고유한 주소로서 전 세계적으로 중복되지 않도록 IEEE에서 관리합니다. MAC 주소는 NIC에 고정적으로 할당되며, 이를 통해 네트워크에서 해당 NIC를 식별할 수 있습니다.

이러한 MAC 주소는 로컬 네트워크에서만 유효합니다. 즉, 같은 LAN(Local Area Network) 내에서만 유효하며, 다른 네트워크 간에는 라우팅 과정에서 해당 MAC 주소가 변환되어 전달됩니다.

따라서, MAC 주소는 네트워크에서 통신을 할 때, 물리적인 주소로서 사용되며, NIC와 같은 하드웨어의 고유한 식별자 역할을 합니다.




# www.naver.com에 접속했을때, 요청을 보내고 받기까지의 과정을 설명

접속하는 과정은 크게 아래와 같은 단계로 구성됩니다.

1. DNS Lookup
 - 사용자가 www.naver.com에 접속하면, 클라이언트 컴퓨터는 먼저 DNS(Domain Name System) 서버에 해당 도메인 이름에 대한 IP 주소를 요청합니다. 이때, 클라이언트 컴퓨터의 로컬 DNS 캐시에 이미 해당 도메인 이름에 대한 IP 주소가 저장되어 있으면, DNS Lookup 과정을 거치지 않고 바로 해당 IP 주소를 사용하여 접속합니다.

2. TCP/IP 연결
 - 클라이언트 컴퓨터는 DNS Lookup을 통해 얻은 서버의 IP 주소로 TCP/IP 연결을 시도합니다. 이때, HTTP 프로토콜을 사용하기 때문에 포트 번호 80이 사용됩니다.

3. HTTP Request
 - TCP/IP 연결이 성공하면, 클라이언트 컴퓨터는 HTTP Request를 생성하여 서버에 전송합니다. HTTP Request에는 사용자가 요청한 페이지나 리소스에 대한 정보가 포함됩니다.

4. 서버 처리
 - 서버는 클라이언트의 요청을 받아서 처리하고, 요청에 대한 응답을 생성합니다. 이때, 서버는 요청된 페이지나 리소스를 찾아서 가져와 응답에 포함시킵니다.

5. HTTP Response
 -  서버가 생성한 응답은 HTTP Response 형태로 클라이언트 컴퓨터로 전송됩니다. HTTP Response에는 요청한 페이지나 리소스에 대한 내용뿐만 아니라, 응답 상태 코드, 응답 헤더 등의 정보도 포함됩니다.

6. 웹 페이지 렌더링
 - 클라이언트 컴퓨터는 HTTP Response를 받아서 웹 페이지를 렌더링합니다. 이때, 웹 페이지에는 HTML, CSS, JavaScript 등의 코드가 포함되어 있으며, 이를 해석하고 실행하여 사용자가 볼 수 있는 형태로 표시됩니다.

위와 같은 단계를 거쳐서 사용자는 www.naver.com에 접속하여 원하는 정보를 얻을 수 있습니다.
# URI와 URL URN
`URI(Uniform Resource Identifier)`, `URL(Uniform Resource Locator)`, `URN(Uniform Resource Name)`은 모두 인터넷에서 리소스를 식별하는 방법을 나타내는 용어입니다.
차이는 URL은 인터넷 상의 자원의 위치를 나타내는 식별자이며, URN은 자원의 이름을 나타내는 식별자입니다. URI는 URL과 URN을 포함하는 인터넷 상의 자원을 고유하게 식별하는 식별자의 일반적인 개념입니다.

URI는 인터넷 상의 자원을 고유하게 식별하는 일반적인 방법을 말하며, URL과 URN은 URI의 하위 개념입니다.
# WAS란 무엇인가요?

`Web Application Server`는 웹 어플리케이션을 실행하기 위한 소프트웨어 환경을 제공하는 서버입니다. 즉, Web Application Server는 웹 어플리케이션을 구동하기 위한 미들웨어입니다.

Web Application Server는 다양한 기능을 제공합니다. 대표적으로는 웹 서버, 데이터베이스 서버, 애플리케이션 서버, 메시지 큐 등이 있습니다. 이러한 기능을 통해 웹 어플리케이션을 실행하기 위한 여러 가지 환경을 제공하고, 웹 어플리케이션의 동작을 관리합니다.

또한, Web Application Server는 웹 어플리케이션을 처리하기 위한 많은 프로토콜과 프로그래밍 언어를 지원합니다. 예를 들어, Java EE, .NET, PHP, Python 등의 다양한 프로그래밍 언어와 HTTP, TCP/IP, SOAP 등의 프로토콜을 지원합니다.

Web Application Server는 대규모 웹 어플리케이션을 실행하기 위해 설계되어 있으며, 안정성과 확장성을 고려한 아키텍처를 갖추고 있습니다. 그리고 웹 서버와 데이터베이스 서버 등의 서버와 통합하여 웹 어플리케이션을 실행할 수 있는 환경을 제공합니다.

# TCP/IP 송수신 구조에 대해 간략히 설명

1. 데이터의 송신

- 응용 계층에서 데이터를 생성하여 전송
- 전송 계층에서 데이터를 패킷으로 분할하여 목적지 주소와 함께 인터넷 계층에 전달
- 인터넷 계층에서는 패킷에 출발지와 목적지 IP 주소를 추가하고, 라우터를 통해 목적지까지 전송
2. 데이터의 수신

- 네트워크 인터페이스 계층에서 데이터를 수신하고, 인터넷 계층에서 목적지 IP 주소를 확인하여 패킷을 추출
- 전송 계층에서 패킷을 재조립하고, 데이터를 응용 계층에 전달
- TCP/IP는 패킷 전송 방식을 사용하기 때문에 데이터가 전송되는 동안 일부 패킷이 손실되거나 순서가 바뀔 수 있습니다. 이를 보완하기 위해 TCP 프로토콜은 데이터 전송의 신뢰성을 보장하는 기능을 제공합니다.
